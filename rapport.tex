\documentclass{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{moreverb}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{listings}

\usetikzlibrary{arrows,positioning,automata,shadows,matrix,calc}

\title{\textbf{Rapport Projet de stage : Limitedness}}
\author{
\bsc {Brebant} Alexandre\\
\bsc {Xue} Juedong}

\begin{document}
\maketitle

\newcommand{\Aut}{\mathcal{A}}
\newcommand{\Ref}{\Aut_{ref}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathcal{R}}

\tableofcontents
\chapter{Introduction au problème}
Durant ce stage, nous avons voulu approfondir nos connaissances dans une branche de l'informatique théorique que nous avons commencé à étudier lors de ce dernier semestre de licence. Ce sont donc les automates et les interrogations qui gravitent autour de cette structure qui nous ont intéressés.\\
Un automate est une machine abstraite qui va accepter ou rejeter des mots dans un alphabet fini. 
Voici l'exemple d'un automate très basique qui accepte tous les mots sur l'alphabet $\{a, b\}$ qui comportent un nombre pair de $a$.
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[state, initial, accepting]			 (A)	                      {1};
   \node[state]         						 (B)   [right=of A]           {2};
 
  \path[->]
             (A)  edge [bend right]   node  [swap]   {a}   (B)
                  edge [loop above]   node           {b}   ()
             (B)  edge [loop above]   node           {b}   ()
                  edge [above]        node           {a}   (A);
\end{tikzpicture}
\end{center}

Pour représenter graphiquement un automate, on utilise donc un graphe orienté dans lequel les sommets du graphe sont les états de l'automate et où chaque arrête correspond à une transition de l'automate, c'est à dire à la lecture d'une lettre. Un mot est accepté par un automate $\Aut$, s'il existe un chemin dans celui-ci, partant d'un état initial et allant jusqu'à un état final en lisant les lettres une par une. Un tel chemin est appelé \textit{chemin acceptant} et l'ensemble des mots acceptés par un automate est appelé \textit{Langage}, on le note $L(\Aut)$.\\\\
Formellement, un automate est défini, par 5 ensembles, de la façon suivante :
\begin{center}
 $ \Aut = \{ A, Q, I, F, \delta \}\ $     avec,
 \end{center}
$A$ : l’alphabet\\
$Q$ : l'ensemble des états\\
$I$ : l'ensemble des états initiaux\\
$F$ : l'ensemble des états finaux\\
$\delta$ : l'ensemble des transitions\\

Nous pouvons donc définir l'automate ci-dessus de cette manière :

\[\Aut = \left(
\begin{array}{rcr}
			A= \{a, b\},\;
			Q=\{1, 2\},\; 
			I=\{1\},\; 
			F=\{1\},\; 
			\delta=
				\left\{
					\begin{array}{rcr}
						(1,a) & \rightarrow & 2 \\
						(2,a) & \rightarrow & 1 \\
						(1,b) & \rightarrow & 1 \\
						(2,b) & \rightarrow & 2 \\
					\end{array}
				\right.
\end{array}
\right)\]

La théorie des automates et des langages est un domaine très actif depuis le milieu du 20e siècle et il existe aujourd'hui plusieurs modèles d'automates nés pour répondre à certaines problématiques. 
\\

Ainsi les automates permettent de caractériser certains langages, par exemple, les automates finis qui sont le modèle de base des automates, définissent ce qu'on appelle les langages rationnels (\cite{Elements-d-algorithmique}). Mais il existe des extensions à ce modèle, comme par exemple les automates à pile qui permettent de définir les langages algébriques (\cite{Elements-d-algorithmique}), qui sont grandement utiliser en analyse syntaxique. Et c'est une autre extension de l'automate fini qui va nous intéresser dans ce rapport : les automates à distance (distance automata).
\\
Ce sont des automates finis, non déterministes, dans lesquels les transitions sont pondérées. On associe donc un coût pour chaque mot accepté par l'automate. Le coût d'un mot correspond au minimum des coûts de tous ses chemins acceptants dans l'automate .\\

Reprenons l'automate représenté plus haut en y ajoutant des coûts sur les transitions :

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[state, initial, accepting]			 (A)	                      {1};
   \node[state]         						 (B)   [right=of A]           {2};
 
  \path[->]
             (A)  edge [bend right]   node  [swap]   {a:1}   (B)
                  edge [loop above]   node           {b:0}   ()
             (B)  edge [loop above]   node           {b:0}   ()
                  edge [above]        node           {a:0}   (A);
\end{tikzpicture}
\end{center}

Avant d'aller plus loin dans la description de cet automate, nous devons définir une notion élémentaire : le déterminisme. Un automate est déterministe si et seulement si il possède un unique état initial et que pour tout état, il existe au plus, une transition par lettre de l'alphabet.\\
Cependant, la déterminisation des automates à distance est encore une question ouverte aujourd'hui. On dit alors qu'un automate à distance est déterministe si l’automate sans les poids l'est.\\

Notre automate à distance est donc déterministe. Cela signifie qu'il n'existe qu'un seul chemin acceptant pour tout les mots reconnus par l'automate et donc qu'il n'existe également qu'un seul coût pour ce mot. On peut observer dans cet exemple que le coût correspondra au nombre de paires de $a$ dans le mot. \\

Ce type d'automate a été présenté par Hashiguchi dans \cite{Hashiguchi:Limitedness-theorem-on-finite-automata-with-distance-functions:1982:a} pour la résolution d'une célèbre problématique, la question de hauteur d'étoile (star height problem) \cite{Eggan:Transition-graphs-and-the-star-height-of-regular-events:1963:a}. Mais les automates à distance posent également un autre problème, la limitation des automates à distance (Limitedness problem).\\
Le problème de limitedness est très simple à comprendre, il est simplement question de savoir si il existe une majoration des coûts pour tous les mots acceptés par un automate à distance.\\
La décidabilité de ce problème n'est pas évidente. En effet il existe des problème similaires dont on a prouvé leur indécidabilité, c'est à dire la preuve qu'il n'existe pas d'algorithme capable de résoudre le problème. Il est par exemple prouvé que la question suivante est indécidable :
\begin{center}
\textit{Soit $\Aut_{1}$ et $\Aut_{2}$ deux automates à distance distincts. Est ce que le coût de $w$ dans $\Aut_{1}$ est égale au coût de $w$ dans $\Aut_{2}$, $\forall w \in L(\Aut_{1}) \cap L(\Aut_{2})$ ?}
\end{center}
Le travail d'Hashiguchi étant considéré comme difficile à comprendre, d'autre chercheurs, comme Simon \cite{Simon:Semigroups-Matrices-over-Tropical:1994:a} ou Leung \cite{Leung&Podolskiy:limitedness-problem-distance-automata::2004:a}, ont étudié le problème et apporté d'autres solutions sur le sujet.\\

Notre travail a donc consisté, dans un premier temps, à lire et comprendre les différents travaux de ces chercheurs afin d'être capable d'implémenter un algorithme permettant la détection de limite dans un automate à distance.

\part{Mise en place théorique de l'algorithme}

\chapter{De l'automate aux matrices}

Le papier dont nous nous sommes le plus servi afin de comprendre et résoudre le problème de limitedness, est \cite{Simon:Semigroups-Matrices-over-Tropical:1994:a} mais il nous a d'abord fallu comprendre la complexité du problème.\\
Pour simplifier les calculs de coûts, il fallait utiliser des structures mathématiques pour représenter la lecture d'une lettre ou d'un mot. Les matrices permettent de créer des "tables de coût" pour la lecture d'une lettre sur les différents états. Pour la suite du rapport nous utiliseront l'automate suivant en tant que référence pour nos exemples :\\

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]
   \node[state, initial]			 (A)	                      {1};
   \node[state, initial, accepting] (B)   [right=of A]           {2};
   \node[state, accepting]			 (C)	[right=of B]         {3};
   \node[state, initial, accepting] (D)   [right=of C]       {4};
 
  \path[->]
             (A)  edge [bend right]   node  [swap]   {b:0}    (B)
                  edge [loop above]   node           {a,b:0}  ()
             (B)  edge [loop above]   node           {a:1}    ()
                  edge [bend right]   node  [swap]   {b:0}    (C)
             (C)  edge [loop above]   node           {a,b:0}  ()
             (D)  edge [loop above]   node           {a:0}    ()
                  edge [loop below]   node           {b:1}    ();
               
\end{tikzpicture}
\[ Automate\; \Ref\]
\end{center}
$\ $

Cet automate est-il limité ? Plus formellement : 
\begin{center}
$\exists ?B \in \N$ tel que $\forall w \in L(\Ref), \; cost(w)\le B$\\
\end{center}

La réponse n'est évidemment pas triviale. C'est pourquoi nous allons utiliser des matrices pour représenter les différents coûts pour une lecture de lettres. La matrice $M(a)$ va par exemple contenir le coût de la lecture de la lettre $a$ depuis tout les états de l'automate de la manière suivante :\\

\[
M_{i,j} = 
				\left\{
					\begin{array}{l }
						n\ ,\ \ s'il\ existe\ une\ transition\ (i, a:n) \rightarrow j \\
						\infty, \ \ sinon \\						
					\end{array}
				\right.
\]

Pour $\Ref$, on a donc par exemple :\\

\begin{center}
$M(a)=$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \infty \& \infty \&  \infty \\
\infty \&  1      \& \infty \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  0      \\
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\foreach \s in {1,2,...,4}{
% bottom index
\node[blue,shift=(m-4-\s.south),yshift=-0.4cm,text height=1ex,](0,0) {$\s$};
}
\foreach \n in {1,2,...,4}{
% right index
\node[green!70!blue,shift=(m-\n-4.west),xshift=1.5cm,text height=1ex,](0,0) {$\n$} ;
}
\end{tikzpicture}
\end{center}
et

\begin{center}
$M(b)=$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  0      \& \infty \&  \infty \\
\infty \&  \infty \& 0       \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  1      \\
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\foreach \s in {1,2,...,4}{
% bottom index
\node[blue,shift=(m-4-\s.south),yshift=-0.4cm,text height=1ex,](0,0) {$\s$};
}
\foreach \n in {1,2,...,4}{
% right index
\node[green!70!blue,shift=(m-\n-4.west),xshift=1.5cm,text height=1ex,](0,0) {$\n$} ;
}
\end{tikzpicture}
\end{center}

Ces matrices sont donc définies sur $\{\N \cup \infty\}$, nous les appellerons matrices de coûts. Leur fonctionnement est très simple : la numérotation de chaque ligne et de chaque colonne correspond aux états de l'automate. Par exemple, dans la matrice de coûts pour la lettre $b$, on a $M(b)_{(2,3)}=0$. Cela signifie que le coût pour aller de l'état 2 à l'état 3 en lisant un $b$ est de 0, ce qu'on peut vérifier sur l'automate. \\

Avant d'aller plus loin il est nécessaire de définir la structure algébrique qui est au cœur de l'algorithme de résolution du problème de limitedness, les semi-anneaux.\\
Un semi-anneau est formé d'un ensemble $E$ muni de deux lois associatives, $\oplus$ et $\otimes$, et d'un élément neutre pour chaque loi. De plus, la première loi est commutative et la seconde est distributive sur la première.\\
Exemple : Les entiers naturels, munis de l'addition et de la multiplication, forment un semi-anneau : $\{ \N,\;+,\;* \}$. Les éléments neutres sont 0 pour l'addition et 1 pour la multiplication. Ces deux lois sont bien associative, l'addition est commutative et la multiplication est distributive sur l'addition. On remarque que la multiplication est également commutative, on dit que $\N$ est un semi-anneau commutatif.\\

Cette structure va nous servir pour définir la multiplication de deux matrices de coûts. Le premier semi-anneau que nous allons définir est celui formé par l'ensemble $\{\N \cup \infty\}$ tel que :
\begin{itemize}
\item $a \oplus b = min(a,\;b)$, avec élément neutre $\infty$
\item $a \otimes b = a + b$, avec élément neutre $0$
\end{itemize}
$\ $

Nous avons maintenant la possibilité de multiplier deux matrices de coûts entre elles afin d'obtenir la matrice correspondant à la concaténation des mots des matrices. On a donc :
\begin{center}
$M(ab) = M(a) \times M(b) =$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \textcolor{red}{0}      \& \textcolor{red}{\infty} \&  \textcolor{red}{\infty} \\
\infty \&  \textcolor{red}{\infty} \& \textcolor{red}{1}      \&  \textcolor{red}{\infty} \\
\infty \&  \infty 					\& 0      					\&  \infty 					 \\
\infty \&  \textcolor{red}{\infty}	\& \textcolor{red}{\infty}	\&  \textcolor{red}{1}      \\
};
\end{tikzpicture}
\end{center}
$\ $

Il est ainsi possible d'obtenir les matrices de coûts pour n'importe quel mots composé de lettres de l'alphabet de l'automate. Et pour obtenir le coût du mot, il faut prendre le minimum des coûts situés dans l'intersection des états initiaux en ligne et des états finaux en colonne. Nous représentons les coûts compris dans cette intersection en rouge.\\
On peut donc dire que $cost(ab) = M(ab)_{(1,2)} = 0$ et il s'obtient en partant de l'état 1 vers l'état 2.\\

Cela ne nous permet cependant pas de déterminer si l'automate est limité ou pas. En effet deux facteurs rendent le nombre de matrices infini : l'ensemble de définition des matrices $\{\N \cup \infty\}$ et le nombre de mots acceptés par l'automate qui est lui aussi infini.
\chapter{Matrices idempotentes}

Dans ce chapitre, nous allons faire évoluer nos matrices afin de rendre leur nombre limité. Tout d'abord, il est nécessaire de modifier le semi-anneaux qui est défini sur un ensemble infini. Dans le problème de limite, la valeur du coût en elle-même n'a pas vraiment d'utilité. Ce qui nous intéresse, c'est de savoir si cette valeur est fixe ou si elle va croître avec la longueur du mot. Si elle croît, ce signifie qu'il existe une boucle dans l'automate dont le poids est strictement supérieur à 0.\\
Nous allons donc définir un ensemble de 4 valeurs qui suffiront à représenter l'intégralité des coûts possibles : 
\begin{itemize}
\item $0$ qui correspond au coût gratuit
\item $1$ qui correspond à un coût potentiellement grand mais fixe
\item $\omega$ qui correspond à un coût instable, qui va croître
\item $\infty$ qui a toujours la même signification, à savoir correspondre aux coûts impossibles à payer
\end{itemize}
$\ $\\
Et on a donc $0 < 1 < \omega < \infty$, il reste maintenant à définir les deux lois associatives du nouveau semi-anneau. La première est identique car nous souhaitons toujours obtenir le minimum parmi tous les chemins : $a \oplus b = min(a,\;b)$. Mais l'addition de coûts ne nous intéresse plus, nous voulons maintenant connaître le plus gros coût parmi toutes les transitions du chemin de lecture d'un mot. On prend donc $a \otimes b = max(a,\;b)$.\\
Nous formons ainsi le semi-anneau qui est le sujet principal de l'article de Simon, le semi-anneau tropical que nous nommeront également $\R$.\\

On remarque tout de fois qu'à partir des matrices de base dont on dispose et de ces deux nouvelles lois, il est impossible d'obtenir la valeur $\omega$ par simple multiplication matricielle dans $\R$. Il nous est donc impossible de détecter les coûts instables, en effet certaines positions contenant la valeur 1 vont rester à inchangées après une multiplication alors que le coût réel va croître d'une certaine valeur pour chaque lecture du mot représenté par la matrice.\\

Reprenons par exemple notre matrice $M(a)$ : \\
\begin{center}
$M(a)=$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \infty \& \infty \&  \infty \\
\infty \&  1      \& \infty \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  0      \\
};
\end{tikzpicture}
\end{center}

Calculons maintenant $M(aa)$ dans $\R$ :

\begin{center}
$M(aa) = M(a) \times M(a) =$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \infty \& \infty \&  \infty \\
\infty \&  1      \& \infty \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  0      \\
};
\end{tikzpicture}
\end{center}

On remarque que $M(aa) = M(a)$. Ce qui implique que $M(aaaa...) = M(a)$ et donc que $M(aaaa...)_{(2,2)} = M(a)_{(2,2)}=1$. \\
Or on peut observer sur l'automate que la lecture répétée de la lettre $a$ en bouclant sur l'état 2 va causer un coût croissant dépendant du nombre de $a$ lus. \\\\
Pour distinguer ce genre de coût de ceux qui ne causent pas ce problème de croissance infinie, il faut donc ajouter un traitement supplémentaire aux matrices dont la multiplication avec elles-même dans R donne la même matrice. On appelle ces matrices des matrices idempotentes.\\\\
Le dernier chapitre de cette partie théorique va donc consister à la détection des coûts instables dans les matrices idempotentes.

\chapter{Matrices stables}
Nous avons donc vu que lorsqu'une matrice est idempotente, il y a un risque que certaines positions voient leur coût exploser à chaque lecture du mot de cette matrice. Il s'avère donc nécessaire de représenter l'itération d'un mot d'une matrice. \\
Au lieu d'écrire $M(aaaaa...)$ comme nous l'avons fait dans le chapitre précédent, nous allons introduire un nouveau symbole afin de simplifier la notation et écrire ce genre de matrices de la façon suivante : $M(a^{\#})$.\\

Soit $w$ un mot, tel que $M(w)$ idempotente, la matrice $M(w^{\#})$ va donc contenir les coûts dans $\R$ d'un nombre quelconque de lectures successives du mot $w$.\\
Dans ces matrices que nous appellerons simplement matrices dièse, il reste donc à déterminer la valeur de chaque position. Dans son article, Simon défini le terme "ancrée" pour définir les positions dont le coût est stable ou va se stabiliser au bout d'un nombre fini d'itération.\\

Lemme : \textit{Soit $w$ un mot tel que $M(w)$ idempotente dans $\R$. Si $M(w)_{(i,j)} = 0$ alors la position $(i,j)$ est ancrée. De plus, la position $(i,j)$ est ancrée si il existe $k \in [1,\; n]$ qui respecte les conditions suivantes :
\begin{itemize}
\item $M(w)_{(k,k)} = 0$
\item $M(w)_{(i,j)} = max(M(w)_{(i,k)}, \; M(w)_{(k,j)}) = 1$
\end{itemize}}
$ $\\
Graphiquement, cela se schématise de la façon suivante :
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]
  \node[state] (i) {i};
  \node[state] (k) [right of=i] {k};
  \node[state] (j) [right of=k] {j};
  \path[->]
			(i)  edge [bend right]		node  [swap]   {1}    (j)
				 edge [above]	node  [swap]   {0/1}    (k)
			(k)  edge [loop above]	node           {0}  		()
				 edge [above]	node  [swap]   {0/1}    (j);
\end{tikzpicture}
\end{center}
$ $\\
\begin{itemize}
\item $M(w)_{(i,j)} = max(M(w)_{(i,k)}, \; M(w)_{(k,j)}) = 1$ signifie qu'on peut atteindre l'état $k$ en payant un coût fixe puis rejoindre en j avec un coût également fixe. 
\item $M(w)_{(k,k)} = 0$ correspond à une boucle de coût 0 sur l'état k. Elle va permettre d'absorber les lectures successives de $w$.
\end{itemize}
$ $\\
Cette configuration permet donc une lecture multiple d'un mot sans que le coût ne grandisse avec le nombre de lectures. D'un point de vue matricielle, il suffit d'appliquer le lemme pour chaque position de la matrice pour laquelle nous voulons obtenir sa "version dièse". Si une position n'est pas ancrée, on dit qu'elle est instable. On a donc :

\[
M(w^{\#})_{(i,j)} = 
				\left\{
					\begin{array}{l }
						\omega\ ,\ \ si\ M(w)_{(i,j)} = 1 \ et\ (i,j)\ est\ instable\\
						M(w)_{(i,j)}, \ \ sinon \\						
					\end{array}
				\right.
\]

Revenons maintenant sur notre automate $\Ref$. Nous avons vu que sa matrice $M(a)$ était idempotente et que par conséquent, il était nécessaire de déterminer sa stabilité.

\begin{center}
$M(a)=$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \infty \& \infty \&  \infty \\
\infty \&  1      \& \infty \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  0      \\
};
\end{tikzpicture}
\end{center}

On a $M(a)_{(2,2)} = 1$ et on remarque qu'on peut prendre $k=1$ ou $k= 3$ ou $k=4$ car on a $M(a)_{(1,1)} = M(a)_{(3,3)} = M(a)_{(4,4)} = 0$.\\
Cependant, la deuxième condition du lemme n'est vérifiée pour aucun de ces $k$ : 
\[\forall k \in \{1,\; 3,\; 4\},\ \ \ M(a)_{(i,j)} \neq max(M(a)_{(i,k)}, \; M(a)_{(k,j)})\]

La position $(2,2)$ est donc instable, on peut alors déterminer la matrice $M(a^{\#})$ :
\begin{center}
$M(a^{\#})=$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \infty \& \infty \&  \infty \\
\infty \&  \omega \& \infty \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  0      \\
};
\end{tikzpicture}
\end{center}
$ $\\
Nous sommes maintenant en possession de l'intégralité des éléments qui vont nous permettre de déterminer si un automate à distance est limité ou non. Comme nous l'avons vu, $\R$ est un semi-anneau défini sur un ensemble de 4 valeurs. Le principe de l'algorithme sera donc le calcul de l'intégralité des matrices de l'automate pour chacune de ses lettres, puis en cas d'impotence, il faudra calculer la matrice dièse correspondante.\\
Une fois l'intégralité des matrices calculée, il ne reste qu'à regarder les valeurs situées dans l'intersection des états initiaux en ligne et des états finaux en colonne comme nous l'avons expliqué dans le chapitre 2. Si le minimum dans chacune de ces matrices est 0 ou 1, alors l'automate sera limité. Mais si l'une (ou plusieurs) d'entre elles a pour minimum $\omega$, alors l'automate ne sera pas limité et le mot correspondant à cette matrice sera celui qui causera le coût non limité.\\\\
Le nombre de matrices calculé augmente très rapidement avec le nombre d'états puisque celui ci défini $n$, la taille des matrices. Le nombre de matrices possibles est donc égal à $4^{n^{2}}$.\\
Pour $\Ref$ par exemple, on a $n=4$ et donc possiblement $4^{4^{2}} = 4\;294\;967\;296$ matrices.\\\\

Une fois cette partie théorique assimilée, ils nous a donc fallu mettre en place des structures permettant le stockage important de matrices ainsi qu'un accès efficace à ces dernières. Nous allons donc dans cette deuxième partie décrire l'implémentation des différentes fonctions et structures que nous avons mis en place ainsi que les choix que nous avons fait pour, à la fois être efficace mais également conserver une certaine clarté dans le code pour que cette partie théorique soit visible au sein des fonctions. 

\part{Exécution détaillée du programme}

\chapter{Réutilisation du programme d'Adrien Boussicault}
Pour l'implémentation de l'algorithme, nous avons choisi de reprendre le code que nous avions utilisé lors du projet d'informatique théorique 2. Ce code comprenait une implémentation des automates de base, quelques fonctions de manipulation, ainsi qu'un module de table de hachage permettant le stockage de structures.\\ 
Nous avons donc commencer par adapter le code existant afin que celui-ci puisse gérer les automates à distance. Voici les structures telles que nous les utilisons dans le programme:\\

\lstset{language={C},frame=tBlR,rulesep=1mm,framesep=5mm,framerule=2pt,xrightmargin=5mm,xleftmargin=5mm,rulecolor={\color[gray]{0.6}},rulesepcolor={\color[gray]{0.9}}}
\begin{lstlisting}[frame=single]
struct _Automate {
	Ensemble * etats;
	Ensemble * alphabet;
	Table* transitions;
	Ensemble * initiaux;
	Ensemble * finaux;
};

typedef struct _Cle {
	int origine;
	int lettre;
	int cout;
} Cle;
\end{lstlisting}
$ $\\
Le nom et le type des variables permettent très facilement de comprendre chaque élément de ces structures. 

Un automate est donc composé de quatre ensembles, \verb?etats?, \verb?alphabet?, \verb?initiaux? et \verb?finaux? et d'une table de hachage contenant les transitions. Les clés de cette table sont décrites dans la structure \verb?Cle? qui contient trois entiers explicites, \verb?origine?, \verb?lettre? et \verb?cout?.\\
Dans la table \verb?transitions?, chaque clé est donc associé à un ensemble qui correspond aux état destination de la transition décrite par les valeurs de la clé. La variable \verb?cout? de la structure \verb?Cle? est la seule variable de structure que nous avons ajouté par rapport au code d'origine. Ensuite, il a fallu modifier toutes les fonctions de modification des automates pour qu'elles prennent en charge la gestion des coûts des transitions.\\
Nous avons également ajouté un accesseur pour cette variable et modifier l'affichage des automate pour que celui-ci soit plus clair.\\

Voici notre automate référence $\Ref$ affiché grâce à la fonction
\begin{center}
\verb?void print_automate( const Automate * automate )? :\\ 
\end{center}

\begin{verbatim}
- Etats :       {0, 1, 2, 3, }
- Initiaux :    {0, 1, 3, }
- Finaux :      {1, 2, 3, }
- Alphabet :    {a, b, }
- Transitions : 
{
         {0} --> (a : 0) --> {0, }
         {0} --> (b : 0) --> {0, 1, }
         {1} --> (a : 1) --> {1, }
         {1} --> (b : 0) --> {2, }
         {2} --> (a : 0) --> {2, }
         {2} --> (b : 0) --> {2, }
         {3} --> (a : 0) --> {3, }
         {3} --> (b : 1) --> {3, }
  
}
\end{verbatim}
$ $\\

On distingue aisément les différents éléments de la structure et l'affichage est très similaire à l'affichage formel que nous avons présenté dans l'introduction. La structure \verb?Mautotmate? ainsi que les fonctions la concernant sont également des ajouts de notre part, nous aborderons leur description dans le chapitre 7.

\chapter{Création et manipulation des matrices}
%pourquoi on utilise l'arbre syntaxique?\\
%aaaaa\\\\
%aaaa
% texmaker  F1 ->> sauvgarder et compiler a la meme fois

Comme nous l'avons vu dans la première partie, le cœur de l'algorithme de résolution du problème de limitedness repose sur la manipulation de matrices représentant les différents coûts de l'automate. Nous avons donc ajouté un module nommé \textit{"Matrice.c"} contenant la structure et les fonctions nécessaires aux manipulations vu dans la première partie. Voici tout d'abord la structure \verb?Matrice? telle que nous l'avons implémenté : \\

\begin{lstlisting}[frame=single]
struct _Matrice {
  int** tab;
  tree mot;
  int taille;
};
\end{lstlisting}
$ $\\\\
On construit ensuite la matrice avec la fonction \verb?creer_matrice(int taille)?. Toutes les matrices sont de la forme carrée $n \times n$ , avec n le nombre d'états de l'automate. C'est pourquoi la taille de la matrice est contenue dans une seule variable. La matrice contient également le mot correspondant à la lecture de la matrice ainsi qu'un tableau à deux dimensions du type int. On alloue alors la mémoire pour la structure de la matrice puis pour le tableau.\\

Pour la destruction, on libère les structures dans l'ordre inverse avec lequel on les à alloué. Sont également présents, trois accesseurs pour chacune des variables de la structure ainsi qu'une fonction d'affichage prenant en compte $\omega$ et $\infty$ que nous avons défini respectivement à $2$ et $3$, comme variables globales, dans \textit{"Matrice.h"}.

On observe que dans notre structure \verb?Matrice? la variable \verb?mot? est de type \verb?tree?, c'est une structure que nous avons implémenté dans \textit{"arbresynthaxique.c"} afin de manipuler facilement et efficacement les mots d'une matrice.\\
En effet, nous avions débuté notre code par une simple structure \verb?char? pour contenir les mots, mais celle-ci s'est révélée bien peu efficace lorsque qu'il a fallu calculer une matrice dièse ou simplement pour la multiplication de deux matrices. \\\\
Avec cette structure \verb?tree?, nous représentons les mots sous forme d'arbres avec trois types de sommets différents :
\begin{itemize}
\item Une lettre de l'alphabet de l'automate qui est un sommet avec aucun fils
\item Le dièse qui est un sommet avec un seul fils, ce qui permet efficacement de transformer une expression $x$ en $x^{\#}$.
\item Le point qui correspond à la concaténation de deux expressions et qui à donc deux fils
\end{itemize}
$\ $

Ainsi on peut manipuler nos mots sans avoir à faire des manipulations fastidieuses et coûteuses de chaînes de caractères. Cette structure nous permet donc d'effectuer des concaténation et de mettre une matrice sous sa forme \textit{"dièse"} en temps constant $O(1)$.\\

Revenons maintenant à notre module \verb?Matrice.c? afin de passer en revue les fonctions principales pour la manipulation de matrices. \\

\verb?Matrice multiplication_in_MnR(Matrice m1,Matrice m2)?\\\\
Cette fonction effectue la multiplication matricielle dans l'ensemble $\R$ que nous avons défini dans le chapitre 3. Les matrices \verb?m1? et \verb?m2? sont forcément de même taille puisqu'elles concernent le même automate.\\
On rappelle que les lois de $\R$ sont $a \oplus b = min(a,\;b)$ et $a \otimes b = max(a,\;b)$. On crée donc une nouvelle matrice m3 qu'on initialise à -1 pour chacune de ses positions, ce qui va nous permettre d'extraire la valeur maximum d'une des deux matrices lors de la multiplication.\\

\verb?int est_idempotent(Matrice m)?\\\\
Le test d'idempotence est très simple puisque comme nous l'avons vu dans la première partie, il suffit de multiplier la matrice avec elle-même, puis de tester l'égalité.\\

\verb?int stable(int i,int j,Matrice m)?\\\\
Cette fonction résulte directement du lemme énoncé dans le chapitre 4. En effet, elle se contente d'effectuer, pour chaque position, tous les tests nécessaires afin que les conditions du lemme soient respectées.\\\\

\verb?Matrice creer_matrice_diese(Matrice m)?\\\\
Comme son nom l'indique, la fonction \verb?creer_mattice_diese? calcul et renvoie la matrice dièse d'une matrice $m$ dans $\R$. Comme vu dans le chapitre 4, il suffit de tester la stabilité de la position si $tab[i][j] = 1$. Si la position n'est pas stable, on remplace sa valeur par $\omega$ sinon, on la laisse à 1.\\\\\\

Grâce à ce module, nous avons maintenant les éléments nécessaires pour manipuler nos matrices définies dans $\R$. Cependant, nous avons vu qu'un très grand nombre de ces matrices allait être calculé. C'est pourquoi il nous a fallu trouver un moyen d'effectuer tous ces calculs de la manière la plus efficace possible.

\chapter{Structure de stockage des matrices}


Le nombre de matrice calculé étant potentiellement très grand, il nous a donc fallu réfléchir à une méthode permettant un calcul optimisé de l'intégralité des matrice de l'automate. C'est à dire qu'il faut organiser les matrice de sorte qu'on sache quelles sont celles qui reste à calculer et éviter de calculer une même matrice plusieurs fois. \\\\
La structure que nous avons choisis n'est autre qu'un automate... Son fonctionnement n'est pas évident mais cette nouvelle structure va simplifier grandement l'algorithme, notamment la condition d'arrêt qui signifie que toute les matrices ont bien été calculée.\\
Nous avons appelé cet automate particulier un \textit{"mautomate"} car c'est simplement un automate qui contient des matrices. Mais avant de présenter le code de cette structure, nous allons expliquer comment celle-ci est pensée. Pour cela nous allons reprendre notre automate $\Ref$ :\\\\

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]
   \node[state, initial]			 (A)	                      {1};
   \node[state, initial, accepting] (B)   [right=of A]           {2};
   \node[state, accepting]			 (C)	[right=of B]         {3};
   \node[state, initial, accepting] (D)   [right=of C]       {4};
 
  \path[->]
             (A)  edge [bend right]   node  [swap]   {b:0}    (B)
                  edge [loop above]   node           {a,b:0}  ()
             (B)  edge [loop above]   node           {a:1}    ()
                  edge [bend right]   node  [swap]   {b:0}    (C)
             (C)  edge [loop above]   node           {a,b:0}  ()
             (D)  edge [loop above]   node           {a:0}    ()
                  edge [loop below]   node           {b:1}    ();
               
\end{tikzpicture}
\[ Automate\; \Ref\]
\end{center}
$\ $\\

Dans un premier temps, nous allons créer un état initial qui sera le départ de tout calcul matriciel.

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]
   \node[state, initial]			 (I)	                      {I};
 \end{tikzpicture}
\end{center}
$\ $\\

L'alphabet sera le même que l'automate sur lequel on travail, ici ${a,\;b}$. Depuis l'état initial, nous allons créer une transition pour chaque lettre de cet alphabet. La destination de ces transitions sera la matrice correspondant à la lettre de la transition. Pour $\Ref$ cela nous donne l'automate suivant :

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]
   \node[state, initial]			 (I)	                      {I};
   \node[state]			 (1)	[above right of=I]    {M(a)};
   \node[state]			 (2)	[below right of=I]    {M(b)};
   
   \path[->]
             (I)  edge   node  [swap]   {a}    (1)
                  edge   node  [swap]   {b}    (2);
               
\end{tikzpicture}
\end{center}
$\ $\\

Maintenant, le but va être de rendre l'automate complet. Pour tout état $M(x_{1})$, $M(x_{2})$ et pour toute lettre $l$ de l'alphabet, Nous aurons donc des transitions de la forme $(M(x_{1}),\; l) \rightarrow M(x_{2})$  avec $M(x_{2}) = M(x_{1}) \times M(l)$\\
Voyons ce que cela donne pour l'état $M(b)$ :

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]
   \node[state, initial]			 (I)	                      {I};
   \node[state]			 (1)	[above right of=I]    	{M(a)};
   \node[state]			 (2)	[below right of=I]    	{M(b)};
   \node[state]			 (3)	[above right of=2]    	{M(ba)};
   \node[state]			 (4)	[right of=2]			{M(bb)};
   
   \path[->]
             (I)  edge   node  [swap]   {a}    (1)
                  edge   node  [swap]   {b}    (2)
             (2)  edge   node  [swap]   {a}    (3)
                  edge   node  [swap]   {b}    (4);
               
\end{tikzpicture}
\end{center}
$\ $\\
 
Pour $M(a)$ le traitement n'est pas le même. En effet nous avons vu dans le chapitre X que la matrice $M(a)$ était idempotente. Cela signifie tout d'abord qu'il va y avoir une boucle sur l'état $M(a)$ pour la lettre $a$. Mais cela signifie également, comme nous l'avons vu dans le chapitre X, que nous allons devoir calculer la matrice $M(a^{\#})$. Deux cas sont possibles : si $M(a^{\#}) = M(a)$ alors la boucle suffit. Mais si ce n'est pas le cas, il fait alors traiter $a^{\#}$ comme une nouvelle lettre de l'automate et recompléter en conséquence : 

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]
   \node[state, initial]			 (I)	                      {I};
   \node[state]			 (1)	[above right of=I]    	{M(a)};
   \node[state]			 (2)	[right of=I]    		{M(b)};
   \node[state]			 (3)	[right of=2]	    	{M(ba)};
   \node[state]			 (4)	[below right of=2]		{M(bb)};
   \node[state]			 (5)	[right of=1]   		 	{M(ab)};
   \node[state]			 (6)	[below right of=I]		{M(a\#)};
   
   \path[->]
             (I)  edge   node  [swap]   {a}    (1)
                  edge   node  [swap]   {b}    (2)
                  edge   node  [swap]   {a\#}   (6)
             (1)  edge   [loop above]    node  [swap]   {a}    (1)
                  edge   node  [swap]   {b}    (5)
             (2)  edge   node  [swap]   {a}    (3)
                  edge   node  [swap]   {b}    (4);
               
\end{tikzpicture}
\end{center}
$\ $\\


On itère ce processus jusqu'à ce que le mautomate soit complet. Celui-ci grandi très rapidement à cause des matrices idempotentes qui ont une chance de rajouter une lettre dans l'alphabet. C'est donc cette structure que nous avons rajouté dans \textit{"automate.c"} et qui est au coeur de l'algorithme de résolution du problème de limitedness.\\

La structure \verb?Mautomate? est composée de trois éléments comme suit :

\begin{lstlisting}[frame=single]
struct _Matrice_Automate{
  Automate * automate;
  Table* t_matrices_etats;
  Table* t_matrices_lettres;
};
\end{lstlisting}
$ $\\\\

Il y a donc un automate et deux table de hachage : \verb?t_matrices_etats? qui stock l'intégralité des matrices calculées et dont la clé correspond à l'état de l'automate qui la contient.La seconde table de hachage, \verb?t_matrices_lettres?, stock également des matrices mais seulement celles qui correspondent à une lettre et la clé est donc cette même lettre. Cette table permet d’accéder facilement aux matrices de base lors du calcul de nouvelles matrice pour chaque transition.
La structure de matrice automate inclut un automate,une tabs qui contient les états,une table qui contient les lettres.\\

Ainsi, n'avons plus qu'à créer un mautomate à partir de l'automate, puis analyser chacune des matrices afin de détecter si l'une d'elle cause un coût $\omega$, c'est-à-dire un coup non-borné.
\\\\
Notre fonction de création, \verb?creer_mautomate(Automate* a)?, alloue la mémoire nécessaire à la structure et effectue également chacune des étapes pour obtenir le mautomate complet à la sortie de la fonction.\\
Nous appelons donc \verb?completer_automate_des_matrices(Mautomate* a)? après l'allocation. Elle fait toutes les multiplications matricielles pour l'alphabet de l'automate et ce, sans s'occuper des matrices idempotentes et donc des dièses. En effet, c'est \verb?void calculer_diese_mautotmate(Mautomate * ma)? qui effectue ce travail, c'est la seconde fonction appliquée lors de la création. \\
Celle-ci parcourt l'intégralité du mautomate à la recherche de matrices idempotentes afin de calculer les matrices dièses correspondantes. Comme nous l'avons vu ce calcul peut générer une nouvelle lettre dans l'alphabet du mautomate. C'est pourquoi dans ce cas la, il est nécessaire d'appeler à nouveau la fonction précédente pour compléter le mautomate. On alterne ainsi les appels de ces fonction jusqu'à ce que l'automate soit complet, avec l'intégralité des matrices de transition.\\

Une fois créé, il ne nous reste plus qu'a analyser les matrices afin de déterminer si l'automate de départ est limité ou non.\\

\chapter{Résolution du problème de limitedness}

La fonction \verb?est_limite(Automate* a, Mautomate * ma)? a besoin de l'automate ainsi que de son mautomate pour déterminer si celui-ci est limité ou pas. Seule la table \verb?t_matrices_etats? est utilisé dans la structure mautomate. En effet seule les valeurs contenues dans les matrices nous interessent. Nous utilisons l'automate pour déterminer l'intervalle des états initiaux servant dans l'analyse des matrices comme nous l'avons vu dans le chapitre X. Si la valeur minimal d'une seule de ces matrice est $\omega$ ou $\infty$, alors l'automate est limité, et cette matrice accompagné du mot qui la caractérise, est celle qui possède le coût illimité.\\
Nous arrêtons à cette première matrice mais il en existe possiblement d'autre. Grâce à notre structure mautomate, il serait aisé d'implémenter une fonction répertoriant l'intégralité des matrices causant un coût \textit{"non-payable"}.\\

Le fichier test, contenant la fonction \verb?main? de notre programme effectue simplement un test avec notre automate $\Ref$. Nous créons cet automate étape par étape (transitions, états initiaux et finaux) en utilisant les fonctions implémentées par Adrien Boussicault, puis nous affichons textuellement le graphe. \\

Nous avons également intégré un affichage graphique via graphviz. C'est un outil qui permet depuis un fichier texte \textit{".gv"}, de créer une image, du format souhaité, de l'automate décrit par le texte. Nous avons donc une fonction \verb?creergraphe(Automate* a)? qui traduit les informations de la structure \verb?Automate? en texte interprétable par graphviz.\\
C'est le fichier auto.gv qui contient toutes ces informations. Nous créons ensuite l'image en appelant la commande de graphviz  \verb?dot -Tpng auto.gv -o auto.png?, on obtient le graphe \textit{auto.png} qu'on ouvre avec la commande \verb?xdg-open? qui va utiliser le visionneur d'image par défaut .\\

L'étape suivante est la plus longue, la création du mautomate. C'est pourquoi nous affichons le temps de calcul pour cette opération. Une fois le mautomate obtenu, la fonction \verb?est_limite(Automate* a, Mautomate * ma)? effectue l'analyse des matrices en temps linéaire puisqu'il s'agit d'un seul parcourt d'une table de hachage.\\
Si l'automate n'est pas limité, nous l'affichons puis le programme s'arrête. Si ce n'est pas le cas, nous demandons si l'utilisateur souhaite afficher l'automate du mautomate. Celui-ci étant possiblement très gros, un affichage n'est pas forcément pertinent. Nous demandons ensuite s'il ne veut pas afficher juste les matrices, et combien il veut en afficher.\\

Voici le résultat de notre programme avec l'automate $\Ref$ avec les 10 premières matrices d'affichées :


\bibliographystyle{abbrv}
\bibliography{limitedness}

\end{document}
