\documentclass{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{moreverb}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amssymb}

\usetikzlibrary{arrows,positioning,automata,shadows,matrix,calc}

\title{\textbf{Rapport Projet de stage : Limitedness}}
\author{
\bsc {Brebant} Alexandre\\
\bsc {Xue} Juedong}

\begin{document}
\maketitle

\newcommand{\Aut}{\mathcal{A}}
\newcommand{\Ref}{\Aut_{ref}}
\newcommand{\N}{\mathbb{N}}

\tableofcontents
\chapter{Introduction au problème}
Durant ce stage, nous avons voulu approfondir nos connaissances dans une branche de l'informatique théorique que nous avons commencé à étudier lors de ce dernier semestre de licence. Ce sont donc les automates et les interrogations qui gravitent autour de cette structure qui nous ont intéressés.\\
Un automate est une machine abstraite qui va accepter ou rejeter des mots dans un alphabet fini. 
Voici l'exemple d'un automate très basique qui accepte tous les mots sur l'alphabet $\{a, b\}$ qui comportent un nombre pair de $a$.
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[state, initial, accepting]			 (A)	                      {1};
   \node[state]         						 (B)   [right=of A]           {2};
 
  \path[->]
             (A)  edge [bend right]   node  [swap]   {a}   (B)
                  edge [loop above]   node           {b}   ()
             (B)  edge [loop above]   node           {b}   ()
                  edge [above]        node           {a}   (A);
\end{tikzpicture}
\end{center}

Pour représenter graphiquement un automate, on utilise donc un graphe orienté dans lequel les sommets du graphe sont les états de l'automate et où chaque arrête correspond à une transition de l'automate, c'est à dire à la lecture d'une lettre. Un mot est accepté par un automate $\Aut$, s'il existe une chemin dans celui-ci, partant d'un état initial et allant jusqu'à un état final en lisant les lettres une par une. Un tel chemin est appelé \textit{chemin acceptant} et l'ensemble des mots acceptés par un automate est appelé \textit{Langage}, on le note $L(\Aut)$.\\\\
Formellement, un automate est défini, par 5 ensembles, de la façon suivante :
\begin{center}
 $ \Aut = \{ A, Q, I, F, \delta \}\ $     avec,
 \end{center}
$A$ : l’alphabet\\
$Q$ : l'ensemble des états\\
$I$ : l'ensemble des états initiaux\\
$F$ : l'ensemble des états finaux\\
$\delta$ : l'ensemble des transitions\\

Nous pouvons donc définir l'automate ci-dessus de cette manière :

\[\Aut = \left(
\begin{array}{rcr}
			A= \{a, b\},\;
			Q=\{1, 2\},\; 
			I=\{1\},\; 
			F=\{1\},\; 
			\delta=
				\left\{
					\begin{array}{rcr}
						(1,a) & \rightarrow & 2 \\
						(2,a) & \rightarrow & 1 \\
						(1,b) & \rightarrow & 1 \\
						(2,b) & \rightarrow & 2 \\
					\end{array}
				\right.
\end{array}
\right)\]

La théorie des automates et des langages est un domaine très actif depuis le milieu du 20e siècle et il existe aujourd'hui plusieurs modèles d'automates nés pour répondre à certaines problématiques. 
\\

Ainsi les automates permettent de caractériser certains langages, par exemple, les automates finis qui sont le modèle de base des automates, définissent ce qu'on appelle les langages rationnels (\cite{Elements-d-algorithmique}). Mais il existe des extensions à ce modèle, comme par exemple les automates à pile qui permettent de définir les langages algébriques (\cite{Elements-d-algorithmique}), qui sont grandement utiliser en analyse syntaxique. Et c'est une autre extension de l'automate fini qui va nous intéresser dans ce rapport : les automates à distance (distance automata).
\\
Ce sont des automates finis, non déterministes, dans lesquels les transitions sont pondérées. On associe donc un coût pour chaque mot accepté par l'automate. Le coût d'un mot correspond au minimum des coûts de tous ses chemins acceptants dans l'automate .\\

Reprenons l'automate représenté plus haut en y ajoutant des coûts sur les transitions :

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[state, initial, accepting]			 (A)	                      {1};
   \node[state]         						 (B)   [right=of A]           {2};
 
  \path[->]
             (A)  edge [bend right]   node  [swap]   {a:1}   (B)
                  edge [loop above]   node           {b:0}   ()
             (B)  edge [loop above]   node           {b:0}   ()
                  edge [above]        node           {a:0}   (A);
\end{tikzpicture}
\end{center}

Avant d'aller plus loin dans la description de cet automate, nous devons définir une notion élémentaire : le déterminisme. Un automate est déterministe si et seulement si il possède un unique état initial et que pour tout état, il existe au plus, une transition par lettre de l'alphabet.\\
Cependant, la déterminisation des automates à distance est encore une question ouverte aujourd'hui. On dit alors qu'un automate à distance est déterministe si l’automate sans les poids l'est.\\

Notre automate à distance est donc déterministe. Cela signifie qu'il n'existe qu'un seul chemin acceptant pour tout les mots reconnus par l'automate et donc qu'il n'existe également qu'un seul coût pour ce mot. On peut observer dans cet exemple que le coût correspondra au nombre de paires de $a$ dans le mot. \\

Ce type d'automate a été présenté par Hashiguchi dans \cite{Hashiguchi:Limitedness-theorem-on-finite-automata-with-distance-functions:1982:a} pour la résolution d'une célèbre problématique, la question de hauteur d'étoile (star height problem) \cite{Eggan:Transition-graphs-and-the-star-height-of-regular-events:1963:a}. Mais les automates à distance posent également un autre problème, la limitation des automates à distance (Limitedness problem).\\
Le problème de limitedness est très simple à comprendre, il est simplement question de savoir si il existe une majoration des coûts pour tous les mots acceptés par un automate à distance.\\
La décidabilité de ce problème n'est pas évidente. En effet il existe des problème similaires dont on a prouvé leur indécidabilité, c'est à dire la preuve qu'il n'existe pas d'algorithme capable de résoudre le problème. Il est par exemple prouvé que la question suivante est indécidable :
\begin{center}
\textit{Soit $\Aut_{1}$ et $\Aut_{2}$ deux automates à distance distincts. Est ce que le coût de $w$ dans $\Aut_{1}$ est égale au coût de $w$ dans $\Aut_{2}$, $\forall w \in L(\Aut_{1}) \cap L(\Aut_{2})$ ?}
\end{center}
Le travail d'Hashiguchi étant considéré comme difficile à comprendre, d'autre chercheurs, comme Simon \cite{Simon:Semigroups-Matrices-over-Tropical:1994:a} ou Leung \cite{Leung&Podolskiy:limitedness-problem-distance-automata::2004:a}, ont étudié le problème et apporté d'autres solutions sur le sujet.\\

Notre travail a donc consisté, dans un premier temps, à lire et comprendre les différents travaux de ces chercheurs afin d'être capable d'implémenter un algorithme permettant la détection de limite dans un automate à distance.

\part{Mise en place théorique de l'algorithme}

\chapter{De l'automate aux matrices}

Le papier dont nous nous sommes le plus servi afin de comprendre et résoudre le problème de limitedness, est \cite{Simon:Semigroups-Matrices-over-Tropical:1994:a} mais il nous a d'abord fallu comprendre la complexité du problème.\\
Pour simplifier les calculs de coûts, il fallait utiliser des structures mathématiques pour représenter la lecture d'une lettre ou d'un mot. Les matrices permettent de créer des "tables de coût" pour la lecture d'une lettre sur les différents états. Pour la suite du rapport nous utiliseront l'automate suivant en tant que référence pour nos exemples :\\

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]
   \node[state, initial]			 (A)	                      {1};
   \node[state, initial, accepting] (B)   [right=of A]           {2};
   \node[state, accepting]			 (C)	[right=of B]         {3};
   \node[state, initial, accepting] (D)   [right=of C]       {4};
 
  \path[->]
             (A)  edge [bend right]   node  [swap]   {b:0}    (B)
                  edge [loop above]   node           {a,b:0}  ()
             (B)  edge [loop above]   node           {a:1}    ()
                  edge [bend right]   node  [swap]   {b:0}    (C)
             (C)  edge [loop above]   node           {a,b:0}  ()
             (D)  edge [loop above]   node           {a:0}    ()
                  edge [loop below]   node           {b:1}    ();
               
\end{tikzpicture}
\[ Automate\; \Ref\]
\end{center}

Cet automate est-il limité ? Plus formellement : 
\begin{center}
$\exists ?B \in \N$ tel que $\forall w \in L(\Ref), \; cost(w)\le B$
\end{center}

La réponse n'est évidemment pas trivial. C'est pourquoi nous allons utiliser des matrice pour représenter les différents coûts pour une lecture de lettres. La matrice $Ma$ va par exemple contenir le coût de la lecture de la lettre $a$ depuis tout les états de l'automate de la manière suivante :\\

\[
M_{i,j} = 
				\left\{
					\begin{array}{l }
						n\ ,\ \ s'il\ existe\ une\ transition\ (i, a:n) \rightarrow j \\
						\infty, \ \ sinon \\						
					\end{array}
				\right.
\]

Pour $\Ref$, on a donc par exemple :\\

\begin{center}
$Ma=$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \infty \& \infty \&  \infty \\
\infty \&  1      \& \infty \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  1      \\
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\foreach \s in {1,2,...,4}{
% bottom index
\node[blue,shift=(m-4-\s.south),yshift=-0.4cm,text height=1ex,](0,0) {$\s$};
}
\foreach \n in {1,2,...,4}{
% right index
\node[green!70!blue,shift=(m-\n-4.west),xshift=1.5cm,text height=1ex,](0,0) {$\n$} ;
}
\end{tikzpicture}
\end{center}
et

\begin{center}
$Mb=$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  0      \& \infty \&  \infty \\
\infty \&  \infty \& 0       \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  1      \\
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\foreach \s in {1,2,...,4}{
% bottom index
\node[blue,shift=(m-4-\s.south),yshift=-0.4cm,text height=1ex,](0,0) {$\s$};
}
\foreach \n in {1,2,...,4}{
% right index
\node[green!70!blue,shift=(m-\n-4.west),xshift=1.5cm,text height=1ex,](0,0) {$\n$} ;
}
\end{tikzpicture}
\end{center}

Ces matrices sont donc définies sur $\{\N \cup \infty\}$. Leur fonctionnement est très simple : la numérotation de chaque ligne et de chaque colonne correspond aux états de l'automate. Par exemple, on a $Mb_{(2,3)}=0$. Cela signifie que le coûts pour aller de l'état 2 à l'état 3 en lisant un $b$ est de 0. 

\chapter{Matrices idempotentes}

\chapter{Matrices stables}

\part{Exécution détaillée du programme}

\chapter{Réutilisation du programme d'Adrien Boussicault}

(présentation des différents modules et fonctions disponible + détails des ajouts pour la gestion des coût, de l'affichage et autres fonctions additionnelles que nous avons ajouté)

\chapter{Création et manipulation des matrice}
(creer\_matrice\_transition, multiplication, etc...)\\

%pourquoi on utilise l'arbre syntaxique?\\
%aaaaa\\\\
%aaaa
% texmaker  F1 ->> sauvgarder et compiler a la meme fois

Dans notre sujet, la matrice représente la matrice d'incidence. Les indices dans la matrice sont des étiquettes d'état. Du coup,dans notre cas,toutes les matrices sont de la forme carrée n x n ,  dont n est le nombre d'états.\\

D'après ce fait,on construit la matrice avec la fonction créer\_matrice(int taille). La matrice contient la taille le mot et un tableau de deux dimensions du type int. alors ,on alloue le mémoire successivement pour la structure de la matrice et le tableau d'int de deux dimensions.\\

Également, pour la destruction, si la matrice est deja NULL, on la laisse tranquille, sinon on des-alloue la structure de la matrice ainsi pour le tableau de deux dimensions.\\

Pour accéder dans la matrice, on a trois successeurs pour obtenir les informations sur le tableau, le mot et la taille de la matrice. \\

vous voyez bien que dans notre structure de la matrice il y a un "mot" qui est du type tree, ce mot est pour exprimer la matrice sous forme d'expression rationnel. le mot contient trois genres de choses: 

	l'alphabet  (dans R a,b,c,etc.)

    la dièse '$\#$'  (la répétition comme * dans l'expression rationnel)

    le point "."  ("."signifie la concaténation)\\
Car on construit le mot par la manipulation de concaténation en collant les sous mot, on include arbresytaxique.h pour bien résoudre le problem de construction du mot.\\

La fonction print\_matrice\_in\_R permet d'afficher la matrice de façon mathématique. en précise, on définit INFINI est 3 et OMÉGA est 2 dans Matrice.h, ici on reconverti INFINI et OMÉGA comme $\infty$ et $\omega$ .\\

la fonction multiplication fais pas la multiplication normale de matrice. en fait on prend deux matrices de la meme taille comme parametres, en suite, on cree un nouveau matrice en attend a retourner.on initialise tous les elelment dans la tableau a -1.puis on  parcours toutes les case des deux tableaux de chacun.


\chapter{Structure de stockage des matrices}

(mautomate, descrption des fonctions de création)

\chapter{Résolution du problème de limitedness}

\bibliographystyle{abbrv}
\bibliography{limitedness}

\end{document}
