\documentclass{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{moreverb}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{xcolor}

\usetikzlibrary{arrows,positioning,automata,shadows,matrix,calc}

\title{\textbf{Rapport Projet de stage : Limitedness}}
\author{
\bsc {Brebant} Alexandre\\
\bsc {Xue} Juedong}

\begin{document}
\maketitle

\newcommand{\Aut}{\mathcal{A}}
\newcommand{\Ref}{\Aut_{ref}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathcal{R}}

\tableofcontents
\chapter{Introduction au problème}
Durant ce stage, nous avons voulu approfondir nos connaissances dans une branche de l'informatique théorique que nous avons commencé à étudier lors de ce dernier semestre de licence. Ce sont donc les automates et les interrogations qui gravitent autour de cette structure qui nous ont intéressés.\\
Un automate est une machine abstraite qui va accepter ou rejeter des mots dans un alphabet fini. 
Voici l'exemple d'un automate très basique qui accepte tous les mots sur l'alphabet $\{a, b\}$ qui comportent un nombre pair de $a$.
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[state, initial, accepting]			 (A)	                      {1};
   \node[state]         						 (B)   [right=of A]           {2};
 
  \path[->]
             (A)  edge [bend right]   node  [swap]   {a}   (B)
                  edge [loop above]   node           {b}   ()
             (B)  edge [loop above]   node           {b}   ()
                  edge [above]        node           {a}   (A);
\end{tikzpicture}
\end{center}

Pour représenter graphiquement un automate, on utilise donc un graphe orienté dans lequel les sommets du graphe sont les états de l'automate et où chaque arrête correspond à une transition de l'automate, c'est à dire à la lecture d'une lettre. Un mot est accepté par un automate $\Aut$, s'il existe un chemin dans celui-ci, partant d'un état initial et allant jusqu'à un état final en lisant les lettres une par une. Un tel chemin est appelé \textit{chemin acceptant} et l'ensemble des mots acceptés par un automate est appelé \textit{Langage}, on le note $L(\Aut)$.\\\\
Formellement, un automate est défini, par 5 ensembles, de la façon suivante :
\begin{center}
 $ \Aut = \{ A, Q, I, F, \delta \}\ $     avec,
 \end{center}
$A$ : l’alphabet\\
$Q$ : l'ensemble des états\\
$I$ : l'ensemble des états initiaux\\
$F$ : l'ensemble des états finaux\\
$\delta$ : l'ensemble des transitions\\

Nous pouvons donc définir l'automate ci-dessus de cette manière :

\[\Aut = \left(
\begin{array}{rcr}
			A= \{a, b\},\;
			Q=\{1, 2\},\; 
			I=\{1\},\; 
			F=\{1\},\; 
			\delta=
				\left\{
					\begin{array}{rcr}
						(1,a) & \rightarrow & 2 \\
						(2,a) & \rightarrow & 1 \\
						(1,b) & \rightarrow & 1 \\
						(2,b) & \rightarrow & 2 \\
					\end{array}
				\right.
\end{array}
\right)\]

La théorie des automates et des langages est un domaine très actif depuis le milieu du 20e siècle et il existe aujourd'hui plusieurs modèles d'automates nés pour répondre à certaines problématiques. 
\\

Ainsi les automates permettent de caractériser certains langages, par exemple, les automates finis qui sont le modèle de base des automates, définissent ce qu'on appelle les langages rationnels (\cite{Elements-d-algorithmique}). Mais il existe des extensions à ce modèle, comme par exemple les automates à pile qui permettent de définir les langages algébriques (\cite{Elements-d-algorithmique}), qui sont grandement utiliser en analyse syntaxique. Et c'est une autre extension de l'automate fini qui va nous intéresser dans ce rapport : les automates à distance (distance automata).
\\
Ce sont des automates finis, non déterministes, dans lesquels les transitions sont pondérées. On associe donc un coût pour chaque mot accepté par l'automate. Le coût d'un mot correspond au minimum des coûts de tous ses chemins acceptants dans l'automate .\\

Reprenons l'automate représenté plus haut en y ajoutant des coûts sur les transitions :

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[state, initial, accepting]			 (A)	                      {1};
   \node[state]         						 (B)   [right=of A]           {2};
 
  \path[->]
             (A)  edge [bend right]   node  [swap]   {a:1}   (B)
                  edge [loop above]   node           {b:0}   ()
             (B)  edge [loop above]   node           {b:0}   ()
                  edge [above]        node           {a:0}   (A);
\end{tikzpicture}
\end{center}

Avant d'aller plus loin dans la description de cet automate, nous devons définir une notion élémentaire : le déterminisme. Un automate est déterministe si et seulement si il possède un unique état initial et que pour tout état, il existe au plus, une transition par lettre de l'alphabet.\\
Cependant, la déterminisation des automates à distance est encore une question ouverte aujourd'hui. On dit alors qu'un automate à distance est déterministe si l’automate sans les poids l'est.\\

Notre automate à distance est donc déterministe. Cela signifie qu'il n'existe qu'un seul chemin acceptant pour tout les mots reconnus par l'automate et donc qu'il n'existe également qu'un seul coût pour ce mot. On peut observer dans cet exemple que le coût correspondra au nombre de paires de $a$ dans le mot. \\

Ce type d'automate a été présenté par Hashiguchi dans \cite{Hashiguchi:Limitedness-theorem-on-finite-automata-with-distance-functions:1982:a} pour la résolution d'une célèbre problématique, la question de hauteur d'étoile (star height problem) \cite{Eggan:Transition-graphs-and-the-star-height-of-regular-events:1963:a}. Mais les automates à distance posent également un autre problème, la limitation des automates à distance (Limitedness problem).\\
Le problème de limitedness est très simple à comprendre, il est simplement question de savoir si il existe une majoration des coûts pour tous les mots acceptés par un automate à distance.\\
La décidabilité de ce problème n'est pas évidente. En effet il existe des problème similaires dont on a prouvé leur indécidabilité, c'est à dire la preuve qu'il n'existe pas d'algorithme capable de résoudre le problème. Il est par exemple prouvé que la question suivante est indécidable :
\begin{center}
\textit{Soit $\Aut_{1}$ et $\Aut_{2}$ deux automates à distance distincts. Est ce que le coût de $w$ dans $\Aut_{1}$ est égale au coût de $w$ dans $\Aut_{2}$, $\forall w \in L(\Aut_{1}) \cap L(\Aut_{2})$ ?}
\end{center}
Le travail d'Hashiguchi étant considéré comme difficile à comprendre, d'autre chercheurs, comme Simon \cite{Simon:Semigroups-Matrices-over-Tropical:1994:a} ou Leung \cite{Leung&Podolskiy:limitedness-problem-distance-automata::2004:a}, ont étudié le problème et apporté d'autres solutions sur le sujet.\\

Notre travail a donc consisté, dans un premier temps, à lire et comprendre les différents travaux de ces chercheurs afin d'être capable d'implémenter un algorithme permettant la détection de limite dans un automate à distance.

\part{Mise en place théorique de l'algorithme}

\chapter{De l'automate aux matrices}

Le papier dont nous nous sommes le plus servi afin de comprendre et résoudre le problème de limitedness, est \cite{Simon:Semigroups-Matrices-over-Tropical:1994:a} mais il nous a d'abord fallu comprendre la complexité du problème.\\
Pour simplifier les calculs de coûts, il fallait utiliser des structures mathématiques pour représenter la lecture d'une lettre ou d'un mot. Les matrices permettent de créer des "tables de coût" pour la lecture d'une lettre sur les différents états. Pour la suite du rapport nous utiliseront l'automate suivant en tant que référence pour nos exemples :\\

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto]
   \node[state, initial]			 (A)	                      {1};
   \node[state, initial, accepting] (B)   [right=of A]           {2};
   \node[state, accepting]			 (C)	[right=of B]         {3};
   \node[state, initial, accepting] (D)   [right=of C]       {4};
 
  \path[->]
             (A)  edge [bend right]   node  [swap]   {b:0}    (B)
                  edge [loop above]   node           {a,b:0}  ()
             (B)  edge [loop above]   node           {a:1}    ()
                  edge [bend right]   node  [swap]   {b:0}    (C)
             (C)  edge [loop above]   node           {a,b:0}  ()
             (D)  edge [loop above]   node           {a:0}    ()
                  edge [loop below]   node           {b:1}    ();
               
\end{tikzpicture}
\[ Automate\; \Ref\]
\end{center}
$\ $

Cet automate est-il limité ? Plus formellement : 
\begin{center}
$\exists ?B \in \N$ tel que $\forall w \in L(\Ref), \; cost(w)\le B$\\
\end{center}

La réponse n'est évidemment pas trivial. C'est pourquoi nous allons utiliser des matrice pour représenter les différents coûts pour une lecture de lettres. La matrice $M(a)$ va par exemple contenir le coût de la lecture de la lettre $a$ depuis tout les états de l'automate de la manière suivante :\\

\[
M_{i,j} = 
				\left\{
					\begin{array}{l }
						n\ ,\ \ s'il\ existe\ une\ transition\ (i, a:n) \rightarrow j \\
						\infty, \ \ sinon \\						
					\end{array}
				\right.
\]

Pour $\Ref$, on a donc par exemple :\\

\begin{center}
$M(a)=$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \infty \& \infty \&  \infty \\
\infty \&  1      \& \infty \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  0      \\
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\foreach \s in {1,2,...,4}{
% bottom index
\node[blue,shift=(m-4-\s.south),yshift=-0.4cm,text height=1ex,](0,0) {$\s$};
}
\foreach \n in {1,2,...,4}{
% right index
\node[green!70!blue,shift=(m-\n-4.west),xshift=1.5cm,text height=1ex,](0,0) {$\n$} ;
}
\end{tikzpicture}
\end{center}
et

\begin{center}
$M(b)=$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  0      \& \infty \&  \infty \\
\infty \&  \infty \& 0       \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  1      \\
};
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\foreach \s in {1,2,...,4}{
% bottom index
\node[blue,shift=(m-4-\s.south),yshift=-0.4cm,text height=1ex,](0,0) {$\s$};
}
\foreach \n in {1,2,...,4}{
% right index
\node[green!70!blue,shift=(m-\n-4.west),xshift=1.5cm,text height=1ex,](0,0) {$\n$} ;
}
\end{tikzpicture}
\end{center}

Ces matrices sont donc définies sur $\{\N \cup \infty\}$, nous les appellerons matrices de coûts. Leur fonctionnement est très simple : la numérotation de chaque ligne et de chaque colonne correspond aux états de l'automate. Par exemple, dans la matrice de coûts pour la lettre $b$, on a $M(b)_{(2,3)}=0$. Cela signifie que le coûts pour aller de l'état 2 à l'état 3 en lisant un $b$ est de 0, ce qu'on peut vérifier sur l'automate. \\

Avant d'aller plus loin il est nécessaire de définir la structure algébrique qui est au cœur de l'algorithme de résolution du problème de limitedness, les semi-anneaux.\\
Un semi-anneau est formé d'un ensemble $E$ muni de deux lois associatives, $\oplus$ et $\otimes$, et d'un élément neutre pour chaque loi. De plus, la première loi est commutative et la seconde est distributive sur la première.\\
Exemple : Les entiers naturels, munis de l'addition et de la multiplication, forment un semi-anneau : $\{ \N,\;+,\;* \}$. Les éléments neutres sont 0 pour l'addition et 1 pour la multiplication. Ces deux lois sont bien associative, l'addition est commutative et la multiplication est distributive sur l'addition. On remarque que la multiplication est également commutative, on dit que $\N$ est un semi-anneau commutatif.\\

Cette structure va nous servir pour définir la multiplication de deux matrices de coûts. Le premier semi-anneau que nous allons définir est celui formé par l'ensemble $\{\N \cup \infty\}$ tel que :
\begin{itemize}
\item $a \oplus b = min(a,\;b)$, avec élément neutre $\infty$
\item $a \otimes b = a + b$, avec élément neutre $0$
\end{itemize}
$\ $

Nous avons maintenant la possibilité de multiplier deux matrices de coûts entre elles afin d'obtenir la matrice correspondant à la concaténation des mots des matrices. On a donc :
\begin{center}
$M(ab) = M(a) \times M(b) =$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \textcolor{red}{0}      \& \textcolor{red}{\infty} \&  \textcolor{red}{\infty} \\
\infty \&  \textcolor{red}{\infty} \& \textcolor{red}{1}      \&  \textcolor{red}{\infty} \\
\infty \&  \infty 					\& 0      					\&  \infty 					 \\
\infty \&  \textcolor{red}{\infty}	\& \textcolor{red}{\infty}	\&  \textcolor{red}{1}      \\
};
\end{tikzpicture}
\end{center}
$\ $

Il est ainsi possible d'obtenir les matrices de coûts pour n'importe quel mots composé de lettres de l'alphabet de l'automate. Et pour obtenir le coût du mot, il faut prendre le minimum des coûts situés dans l'intersection des états initiaux en ligne et des états finaux en colonne. Nous représentons les coûts compris dans cette intersection en rouge.\\
On peut donc dire que $cost(ab) = M(ab)_{(1,2)} = 0$ et il s'obtient en partant de l'état 1 vers l'état 2.\\

Cela ne nous permet cependant pas de déterminer si l'automate est limité ou pas. En effet deux facteurs rendent le nombre de matrices infini : l'ensemble de définition des matrices $\{\N \cup \infty\}$ et le nombre de mots acceptés par l'automate qui est lui aussi infini.
\chapter{Matrices idempotentes}

Dans ce chapitre, nous allons faire évoluer nos matrices afin de rendre leur nombre limité. Tout d'abord, il est nécessaire de modifier le semi-anneaux qui est défini sur un ensemble infini. Dans le problème de limite, la valeur du coût en elle-même n'a pas vraiment d'utilité. Ce qui nous intéresse, c'est de savoir si cette valeur est fixe ou si elle va croître avec la longueur du mot. Si elle croît, ce signifie qu'il existe une boucle dans l'automate dont le poids est strictement supérieur à 0.\\
Nous allons donc définir un ensemble de 4 valeurs qui suffiront à représenter l'intégralité des coûts possibles : 
\begin{itemize}
\item $0$ qui correspond au coût gratuit
\item $1$ qui correspond à un coût potentiellement grand mais fixe
\item $\omega$ qui correspond à un coût instable, qui va croître
\item $\infty$ qui a toujours la même signification, à savoir correspondre aux coûts impossibles à payer
\end{itemize}
$\ $\\
Et on a donc $0 < 1 < \omega < \infty$, il reste maintenant à définir les deux lois associatives du nouveau semi-anneau. La première est identique car nous souhaitons toujours obtenir le minimum parmi tous les chemins : $a \oplus b = min(a,\;b)$. Mais l'addition de coûts ne nous intéresse plus, nous voulons maintenant connaître le plus gros coût parmi toutes les transitions du chemin de lecture d'un mot. On prend donc $a \otimes b = max(a,\;b)$.\\
Nous formons ainsi le semi-anneau qui est le sujet principal de l'article de Simon, le semi-anneau tropical que nous nommeront également $\R$.\\

On remarque tout de fois qu'à partir des matrices de base dont on dispose et de ces deux nouvelles lois, il est impossible d'obtenir la valeur $\omega$ par simple multiplication matricielle dans $\R$. Il nous est donc impossible de détecter les coûts instables, en effet certaines positions contenant la valeur 1 vont rester à inchangées après une multiplication alors que le coût réel va croître d'une certaine valeur pour chaque lecture du mot représenté par la matrice.\\

Reprenons par exemple notre matrice $M(a)$ : \\
\begin{center}
$M(a)=$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \infty \& \infty \&  \infty \\
\infty \&  1      \& \infty \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  0      \\
};
\end{tikzpicture}
\end{center}

Calculons maintenant $M(aa)$ dans $\R$ :

\begin{center}
$M(aa) = M(a) \times M(a) =$
\begin{tikzpicture}[baseline=-\the\dimexpr\fontdimen22\textfont2\relax ]
\matrix(m)[matrix of math nodes,left delimiter=(,right delimiter=),inner sep=4pt,ampersand replacement=\&]
{
0      \&  \infty \& \infty \&  \infty \\
\infty \&  1      \& \infty \&  \infty \\
\infty \&  \infty \& 0      \&  \infty \\
\infty \&  \infty \& \infty \&  0      \\
};
\end{tikzpicture}
\end{center}

On remarque que $M(aa) = M(a)$. Ce qui implique que $M(aaaa...) = M(a)$ et donc que $M(aaaa...)_{(2,2)} = M(a)_{(2,2)}=1$. \\
Or on peut observer sur l'automate que la lecture répétée de la lettre $a$ en bouclant sur l'état 2 va causer un coût croissant dépendant du nombre de $a$ lus. Il faut donc ajouter un traitement supplémentaire aux matrices dont la multiplication avec elles-même dans R donne la même matrice. On appelle ces matrice des matrices idempotentes.\\\\
Le dernier chapitre de cette partie théorique va donc consister à la détection des coût instables dans les matrices idempotente.

\chapter{Matrices stables}

\part{Exécution détaillée du programme}

\chapter{Réutilisation du programme d'Adrien Boussicault}

(présentation des différents modules et fonctions disponible + détails des ajouts pour la gestion des coût, de l'affichage et autres fonctions additionnelles que nous avons ajouté)

\chapter{Création et manipulation des matrice}
(creer\_matrice\_transition, multiplication, etc...)\\

%pourquoi on utilise l'arbre syntaxique?\\
%aaaaa\\\\
%aaaa
% texmaker  F1 ->> sauvgarder et compiler a la meme fois

Dans notre sujet, la matrice représente la matrice d'incidence. Les indices dans la matrice sont des étiquettes d'état. Du coup,dans notre cas,toutes les matrices sont de la forme carrée n x n ,  dont n est le nombre d'états.\\

D'après ce fait,on construit la matrice avec la fonction créer\_matrice(int taille). La matrice contient la taille le mot et un tableau de deux dimensions du type int. alors ,on alloue le mémoire successivement pour la structure de la matrice et le tableau d'int de deux dimensions.\\

Également, pour la destruction, si la matrice est déjà NULL, on la laisse tranquille, sinon on des-alloue la structure de la matrice ainsi pour le tableau de deux dimensions.\\

Pour accéder dans la matrice, on a trois successeurs pour obtenir les informations sur le tableau, le mot et la taille de la matrice. \\

vous voyez bien que dans notre structure de la matrice il y a un "mot" qui est du type tree, ce mot est pour exprimer la matrice sous forme d'expression rationnel. le mot contient trois genres de choses: 

	l'alphabet  (dans R a,b,c,etc.)

    la dièse '$\#$'  (la répétition comme * dans l'expression rationnel)

    le point "."  ("."signifie la concaténation)\\
Car on construit le mot par la manipulation de concaténation en collant les sous mot, on include arbresytaxique.h pour bien résoudre le problem de construction du mot.\\

La fonction print\_matrice\_in\_R permet d'afficher la matrice de façon mathématique. en précise, on définit INFINI est 3 et OMÉGA est 2 dans Matrice.h, ici on reconverti INFINI et OMÉGA comme $\infty$ et $\omega$ .\\

La fonction multiplication fais pas la multiplication normale de matrice. en fait on prend deux matrices de la même taille comme paramètres m1 et m2, en suite, on crée un nouveau matrice m3.on initialise tous les élément de m3 a -1.puis on  parcours toutes les cases des deux tableaux de matrice m1 et m2. on compare les valeurs de la même position de ces deux matrices et redéfinie la valeur de m3 comme le max de m1 et m2,si sa valeur est  -1.sinon on définit la valeur comme  le min des deux matrices dans la même position. \\

Le principe de la fonction est_idempotent est facile, on fait la multiplication du matrice dans R et on teste si le produit généré reste pareille comme ce matrice.si c'est vrai alors c'est une matrice idempotent.\\

La fonction stable est produise par le théorème de \\


La fonction creer\_mattice\_diese calcul et renvoie la matrice dièse d'une matrice dans R.si la matrice n'est pas dans R,alors on peut pas le traiter,on retourne NULL et print "erreur".si c'est d'une matrice dans R,on crée une nouvelle  et le remplie la matrice par la règle suivante:
si tab[i][j] vaut 1 et a la position i j,la valeur est stable,alors on définit tab[i][j] a OMEGA.\\

\chapter{Structure de stockage des matrices}

(mautomate, description des fonctions de création)
La structure de matrice automate inclut un automate,une table qui contient les états,une table qui contient les lettres.\\

Il y a des accesseurs pour lire le coût,la lettre,le origine de la clé.la fonction comparer\_cle utilise ces accesseur pour comparer deux clés données.elle va retourner 0 si et seulement si les deux clés sont équaux.\\

Pour créer une automate,on tout d'abord alloue la mémoire nécessaire pour lui.en suite, on crée et initialise 6 choses pour cette automate: l'ensemble des états,l'ensemble des alphabets,l'ensemble des transitions,l'ensemble des états initiaux,l'ensemble des états finaux et l'ensemble des états vide.\\

Également,pour détruire une automate,on libère successivement les 6 choses dans l'automate et libère l'automate lui-même a la fin.\\

On a tous les outils pour accéder l'automate et le modifier.par exemple,on a get\_etats pour lire tous les états dans l'automate.on a aussi ajouter\_etats pour insérer une nouveau états dans l'automate.ainsi pour les autres choses dans l'automate.\\

La fonction copier\_automate retourner une copie de l'automate donnée,on crée et alloue une automate qui s'appelle res,en suites ,on remplie la même contenu  dans l'automate copie en parcourant successivement les 6 choses notées dessus.par exemple,pour copier les états dans la nouvelle automate,on parcourt l'états un par un en lisant l'ensemble des états avec l'accesseur get\_etats,et ajouter l'états lu dans l'automate res avec la fonction ajouter\_etat.on le boucle si le suivant de cet ensemble parcourir par nous n'est pas vide.on fais la même choses pour les autres.a la fin,on retourne cet automate res.\\

la fonction creer\_automate\_etat\_different renvoie l'automatedestination,dont le nom de tous les etat est different du nom des etats de l'automate source en utlisant la fonctions get\_etat\_libere,on parcourt tous les etats dans l'automate,s'il y a des etats non utilisee, on prend ce etat qui est libre et non utilisee pour remplace le ancien etat dans l'automate source en gardant tous ces ancient transitions lient avec les autres etats.

la fonction creer\_automate\_etat\_0_n

la fonction translater_etat

print\_automate

print\_mautomate

supprimer\_etats

ajouter\_transitions

est\_complet

completer\_automate

calcule\_diese\_mautomate

est\_limite

la fonction creer\_mautomate 

liberer\_mautomate




\chapter{Résolution du problème de limitedness}

Dans la fonction main du fichier test_automate.c,on crée une automate comme on veux en ajoutant des états initiaux,des états finaux et des transitions qui lient les différent états.en suites,on va tester cet automate ,regarde s'il est limite.\\

tout d'abord,on va essayer d'afficher cet automate dans un graphe visuelle,on inclue un outils pour afficher l'automate qui s'appelle  graphiz, ce outils va lire un fichier formelle qui comprendre les informations de l'automate.\\
on utilise la fonction creergraphe pour créer un fichier auto.gv qui porte tous les informations formelle dépend notre automate construit au début.en utilisant ce fichier auto.gv et la commande de graphiz "dot -Tpng auto.gv -o auto.png" on obtient le graphe auto.png.on le ouvrir avec le logiciel  d'image visionneur par défaut .\\
en suite,la première étape pour test la limite de l'automate est la création du mautomate.on afficher la limite de l'automate avec la fonction est\_limite.s'il n'est pas limite,on retourne le premier matrice qui provoque le cout infini de cet automate.on print le mautomate a la fin.


\bibliographystyle{abbrv}
\bibliography{limitedness}

\end{document}
